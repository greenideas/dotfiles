#+TITLE: Emacs Configuration
#+AUTHOR: Matt Henry
#+EMAIL: matthew.w.henry@gmail.com
#+STARTUP: showeverything
#+OPTIONS: toc:nil num:nil

* Configure =use-package=

=use-package= will automatically install any package invoked in a
config file that isn't already installed. It just needs a little
configuration in init.el.

  #+begin_src emacs-lisp
    (use-package use-package-ensure-system-package
      :ensure t)
    (setq use-package-always-ensure t)
  #+end_src

* Environment Variables

  #+begin_src emacs-lisp
    (let ((path (shell-command-to-string ". ~/.zshrc; echo -n $PATH")))
    (setenv "PATH" path)
    (setq exec-path
          (append
           (split-string-and-unquote path ":")
           exec-path)))
  #+end_src

* Configure UI

** Emacs UI config

I like as little chrome as possible.

  #+begin_src emacs-lisp
    (tool-bar-mode 0)    ; Hide menu bar
    (scroll-bar-mode -1) ; Hide scroll bar
  #+end_src

Don't give me all of that default emacs startup garbage.

  #+begin_src emacs-lisp
    ;; Suppress startup bling
    (setq inhibit-startup-message t)
    (setq inhibit-splash-screen t)
    (setq initial-scratch-message nil)
  #+end_src

** Theme

Used to use solarized, because I'm a solarized kind of guy, but I'm
really digging spacemacs dark!

  #+begin_src emacs-lisp
    (use-package spacemacs-theme
      :defer t
      :init (load-theme 'spacemacs-dark t))
  #+end_src

I held out against programming ligatures for as long as I could, but
damn they just look so good in =R= code and JS arrow functions.

  #+begin_src emacs-lisp
    (mac-auto-operator-composition-mode) ;; Enable ligatures
    (set-face-attribute 'default nil :family "Fira Code" :height 140)
    (set-face-attribute 'fixed-pitch nil :family "Fira Code" :height 140)
    (set-face-attribute 'variable-pitch nil :family "Georgia")
  #+end_src

* Utilities

** Evil

  #+begin_src emacs-lisp
    (use-package evil
      :ensure t ;; install the evil package if not installed
      :init ;; tweak evil's configuration before loading it
      (setq evil-search-module 'evil-search)
      (setq evil-ex-complete-emacs-commands nil)
      (setq evil-vsplit-window-right t)
      (setq evil-split-window-below t)
      (setq evil-shift-round nil)
      (setq evil-want-C-u-scroll t)
      :config ;; tweak evil after loading it
      (evil-mode))

    (use-package evil-org
      :ensure t
      :after org
      :config
      (add-hook 'org-mode-hook 'evil-org-mode)
      (add-hook 'evil-org-mode-hook
                (lambda ()
                  (evil-org-set-key-theme)))
      (require 'evil-org-agenda)
      (evil-org-agenda-set-keys))
  #+end_src

** ido

Use =ido-mode= for buffers and files. I don't know if this is really
/en vogue/ anymore, but it works for me for now.

  #+begin_src emacs-lisp
    (setq ido-enable-flex-matching t)
    (ido-mode 1)
    (setq ido-everywhere t)
  #+end_src

** Company

  #+begin_src emacs-lisp
    (use-package company)
    (add-hook 'after-init-hook 'global-company-mode)
  #+end_src


** pdf-tools

  #+begin_src emacs-lisp
    (use-package pdf-tools)

    (pdf-loader-install)
  #+end_src

** web-mode

=web-mode= has decent JSX support, so let's just load that and have it
take over for html & js files.

  #+begin_src emacs-lisp
    (use-package web-mode)
    (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.js[x]?\\'" . web-mode))

    ;; Indent two spaces
    (setq web-mode-markup-indent-offset 2)
    (setq web-mode-css-indent-offset 2)
    (setq web-mode-code-indent-offset 2)

    (add-hook 'web-mode-hook
          (lambda ()
            ;; short circuit js mode and just do everything in jsx-mode
            (if (equal web-mode-content-type "javascript")
                (web-mode-set-content-type "jsx")
              (message "now set to: %s" web-mode-content-type))))
  #+end_src

** prettier

  #+begin_src emacs-lisp
    (use-package prettier-js)
    (add-hook 'web-mode-hook 'prettier-js-mode)
  #+end_src

** Emmet

  #+begin_src emacs-lisp
    (use-package emmet-mode
        :ensure t)

    (add-hook 'sgml-mode-hook 'emmet-mode)
    (add-hook 'css-mode-hook  'emmet-mode)
    (add-hook 'web-mode-hook  'emmet-mode)
    (setq emmet-move-cursor-between-quotes t) ;; move point to first quote
    (setq emmet-expand-jsx-className? t)      ;; expand to className in JSX
  #+end_src

** Flycheck

Flycheck is a package for running linters & static analysis tools. I
cribbed configs from [[http://codewinds.com/blog/2015-04-02-emacs-flycheck-eslint-jsx.html][this post]] and will probably take more from there
going forward.

  #+begin_src emacs-lisp
    (use-package flycheck)

    ;; turn on flychecking globally
    (add-hook 'after-init-hook #'global-flycheck-mode)

    ;; disable jshint since we prefer eslint checking
    (setq-default flycheck-disabled-checkers
      (append flycheck-disabled-checkers
        '(javascript-jshint)))

    ;; use eslint with web-mode for jsx files
    (flycheck-add-mode 'javascript-eslint 'web-mode)

    ;; customize flycheck temp file prefix
    (setq-default flycheck-temp-prefix ".flycheck")

    ;; disable json-jsonlist checking for json files
    (setq-default flycheck-disabled-checkers
      (append flycheck-disabled-checkers
        '(json-jsonlist)))
  #+end_src

* Configure writing environment

This bit inspired by/cribbed from [[https://github.com/hrs/dotfiles/blob/master/emacs/.emacs.d/configuration.org][Harry Schwarz.]]

=AutoFillMode= automatically wraps paragraphs, kinda like hitting =M-q=. I wrap
a lot of paragraphs, so this automatically wraps 'em when I'm writing text,
Markdown, or Org. At some point maybe I'll go back to
[[https://www.emacswiki.org/emacs/VisualLineMode][VisualLineMode]]. Who knows?

Enable =auto-fill-mode= to add line breaks after reaching the column
width. Do this for text, md, and org files.

  #+begin_src emacs-lisp
    (add-hook 'text-mode-hook 'auto-fill-mode)
    (add-hook 'gfm-mode-hook 'auto-fill-mode)
    (add-hook 'org-mode-hook 'auto-fill-mode)
  #+end_src

** Code editing

Use spaces! Two of them!

  #+begin_src emacs-lisp
    (setq-default indent-tabs-mode nil)
    (setq-default tab-width 2)
  #+end_src


  #+begin_src emacs-lisp
    (add-hook 'before-save-hook 'whitespace-cleanup)
  #+end_src

Save backups in their own directory.

  #+begin_src emacs-lisp
    (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
  #+end_src

*** Javascript

Use tern for language and project autocompletion in conjunction with
=company=. This was only sort of working before because I was only
using =company-tern= without the =tern= package, but thanks to this [[https://emacs.stackexchange.com/questions/47275/how-to-hook-tern-and-web-mode-on-certain-files][SO
post]], it's working great now.

  #+begin_src emacs-lisp
    (use-package tern
        :ensure-system-package (tern . "npm i -g tern")
        :config
        (add-hook 'web-mode-hook 'tern-mode))

    (use-package company-tern
        :requires tern
        :config
        (add-to-list 'company-backends 'company-tern))
  #+end_src

*** TODO TypeScript

I haven't written a line of TypeScript yet but I plan to! So naturally
I already started looking for emacs integration so I don't have to use
VSCode. Seems like [[https://github.com/ananthakumaran/tide][tide-mode]] is the way to go according to the
comments [[https://emacs.cafe/emacs/javascript/setup/2017/05/09/emacs-setup-javascript-2.html][here]].

*** TODO JSX

Look at [[https://github.com/felipeochoa/rjsx-mode][=rjsx-mode=]] to improve JSX support

* Org

  #+begin_src emacs-lisp
    (use-package org-bullets
      :init
      (add-hook 'org-mode-hook 'org-bullets-mode))
  #+end_src

Add a template to insert an =elisp= block per [[https://orgmode.org/manual/Structure-Templates.html][=org-tempo=]]

  #+begin_src emacs-lisp
    (require 'org-tempo)
    (add-to-list 'org-structure-template-alist
                 '("el" . "src emacs-lisp"))
  #+end_src

** Capture

  #+begin_src emacs-lisp
    (server-start)
    (add-to-list 'load-path "~/Dropbox/Notes")
    (require 'org-protocol)
  #+end_src

  #+begin_src emacs-lisp
    (setq org-capture-templates `(
        ("p" "Protocol" entry (file+headline ,(concat org-directory "notes.org") "Inbox")
            "* %^{Title}\nSource: %u, %c\n #+BEGIN_QUOTE\n%i\n#+END_QUOTE\n\n\n%?")
        ("L" "Protocol Link" entry (file+headline ,(concat org-directory "notes.org") "Inbox")
            "* %? [[%:link][%:description]] \nCaptured On: %U")
        ))
  #+end_src
* Custom functions

Cribbed shamelessly from [[https://kieranhealy.org/blog/archives/2009/10/12/make-shift-enter-do-a-lot-in-ess/][Kieran Healy]]. Give S-RET superpowers in an ESS buffer.

  #+begin_src emacs-lisp
    (setq ess-ask-for-ess-directory nil)
    (setq ess-local-process-name "R")
    (setq ansi-color-for-comint-mode 'filter)
    (setq comint-scroll-to-bottom-on-input t)
    (setq comint-scroll-to-bottom-on-output t)
    (setq comint-move-point-for-output t)
    (defun my-ess-start-R ()
      (interactive)
      (if (not (member "*R*" (mapcar (function buffer-name) (buffer-list))))
          (progn
            (delete-other-windows)
            (setq w1 (selected-window))
            (setq w1name (buffer-name))
            (setq w2 (split-window w1 nil t))
            (R)
            (set-window-buffer w2 "*R*")
            (set-window-buffer w1 w1name))))
    (defun my-ess-eval ()
      (interactive)
      (my-ess-start-R)
      (if (and transient-mark-mode mark-active)
          (call-interactively 'ess-eval-region)
        (call-interactively 'ess-eval-line-and-step)))
    (add-hook 'ess-mode-hook
              '(lambda()
                 (local-set-key [(shift return)] 'my-ess-eval)))
    (add-hook 'inferior-ess-mode-hook
              '(lambda()
                 (local-set-key [C-up] 'comint-previous-input)
                 (local-set-key [C-down] 'comint-next-input)))
    (add-hook 'Rnw-mode-hook
              '(lambda()
                 (local-set-key [(shift return)] 'my-ess-eval)))

  #+end_src
